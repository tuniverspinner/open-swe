import { loadModel, Task } from "../../../utils/load-model.js";
import { shellTool } from "../../../tools/index.js";
import { PlannerGraphState, PlannerGraphUpdate } from "../types.js";
import { GraphConfig } from "@open-swe/shared/open-swe/types";
import { createLogger, LogLevel } from "../../../utils/logger.js";
import { getMessageContentString } from "@open-swe/shared/messages";
import { getUserRequest } from "../../../utils/user-request.js";
import { isHumanMessage } from "@langchain/core/messages";
import { formatFollowupMessagePrompt } from "../utils/followup-prompt.js";
import { getRepoAbsolutePath } from "../../../utils/git.js";
import { SANDBOX_ROOT_DIR } from "@open-swe/shared/constants";

const logger = createLogger(LogLevel.INFO, "GeneratePlanningMessageNode");

const systemPrompt = `You are operating as a terminal-based agentic coding assistant built by LangChain. It wraps LLM models to enable natural language interaction with a local codebase. You are expected to be precise, safe, and helpful.
{FOLLOWUP_MESSAGE_PROMPT}

You MUST adhere to the following criteria when gathering context for the plan:
- Your ONLY job is to gather context for the plan.
  - You are NOT allowed to take any write/update actions, instead you must only take read actions to gather context.
  - All write/update actions will be taken in a later step, only after you've gathered all the necessary context.
- Keep in mind you are only permitted to make a maximum of 6 tool calls to gather all your context. Ensure each action is of high quality, and targeted to aid in generating a plan.
- Always use \`rg\` instead of \`grep/ls -R\` because it is much faster and respects gitignore.
  - Always use glob patterns when searching with \`rg\` for specific file types. For example, to search for all TSX files, use \`rg -i star -g **/*.tsx project-directory/\`. This is because \`rg\` does not have built in file types for every language.
- If you determine you've gathered enough context to generate a plan, simply reply with 'done' and do NOT call any tools.
- Not generating a tool call will be interpreted as an indication that you've gathered enough context to generate a plan.
- The repo is already cloned, and located inside {REPO_DIRECTORY}

Below is an up to date tree of the codebase (going 3 levels deep). This is up to date, and is updated after every action you take. Always assume this is the most up to date context about the codebase.
It was generated by using the \`tree\` command, passing in the gitignore file to ignore files and directories you should not have access to (\`git ls-files | tree --fromfile -L 3\`). It is always executed inside the repo directory: {REPO_DIRECTORY}
{CODEBASE_TREE}

Your current working directory is: {CURRENT_WORKING_DIRECTORY}

The user's request is the first user message in the conversation below. Ensure you generate your plan in accordance with the user's request.
`;

function formatSystemPrompt(state: PlannerGraphState): string {
  // It's a followup if there's more than one human message.
  const isFollowup = state.internalMessages.filter(isHumanMessage).length > 1;

  return systemPrompt
    .replace(
      "{FOLLOWUP_MESSAGE_PROMPT}",
      isFollowup ? formatFollowupMessagePrompt(state.plan) : "",
    )
    .replaceAll("{REPO_DIRECTORY}", getRepoAbsolutePath(state.targetRepository))
    .replaceAll(
      "{CODEBASE_TREE}",
      `<codebase-tree>\n${state.codebaseTree || "No codebase tree generated yet."}\n</codebase-tree>`,
    )
    .replaceAll("{CURRENT_WORKING_DIRECTORY}", SANDBOX_ROOT_DIR);
}

export async function generateAction(
  state: PlannerGraphState,
  config: GraphConfig,
): Promise<PlannerGraphUpdate> {
  const model = await loadModel(config, Task.ACTION_GENERATOR);
  const tools = [shellTool];
  const modelWithTools = model.bindTools(tools, {
    tool_choice: "auto",
    parallel_tool_calls: false,
  });

  const userRequest = getUserRequest(state.internalMessages, {
    returnFullMessage: true,
  });

  const response = await modelWithTools
    .withConfig({ tags: ["nostream"] })
    .invoke([
      {
        role: "system",
        content: formatSystemPrompt(state),
      },
      userRequest,
      ...state.plannerMessages,
    ]);

  logger.info("Generated planning message", {
    ...(getMessageContentString(response.content) && {
      content: getMessageContentString(response.content),
    }),
    ...(response.tool_calls?.[0] && {
      name: response.tool_calls?.[0].name,
      args: response.tool_calls?.[0].args,
    }),
  });

  return {
    messages: [response],
    plannerMessages: [response],
  };
}
